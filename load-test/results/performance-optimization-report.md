# 위치 기반 매치 검색 성능 최적화 보고서

## 1. 배경

### 문제 상황
위치 기반 매치 검색 API(`GET /api/matches?latitude=...&longitude=...&distance=...`)의 응답 시간이 최대 28초에 달하며, TPS가 3.83에 불과하여 서비스 품질에 심각한 영향을 미침.

### 목표
- P95 응답시간 2초 이하
- TPS 향상을 통한 동시 사용자 처리량 증가

---

## 2. 기술 선택: MySQL ST_DISTANCE vs Redis GeoHash

### 2.1 MySQL ST_DISTANCE_SPHERE 방식

**동작 원리**
- `ST_DISTANCE_SPHERE(POINT(lat, lng), location)` 함수로 두 좌표 간 거리 계산
- Spatial Index를 활용한 Bounding Box 필터링 후 정밀 거리 계산

**한계점**
- 매 요청마다 DB 조회 필요 (I/O 비용)
- 거리 계산은 여전히 실시간 연산 (CPU 비용)
- 인덱스가 있어도 대량 데이터에서 성능 저하

**적용 결과**
| 지표 | Before | After |
|------|--------|-------|
| TPS | 3.83 | 37.16 |
| P95 응답시간 | 28s | 1.28s |

9.7배 개선되었으나, DB 연산 의존도가 여전히 높음.

---

### 2.2 Redis GeoHash 방식

**동작 원리**
- 위도/경도를 52비트 정수(GeoHash)로 인코딩하여 Sorted Set에 저장
- `GEORADIUS` 명령으로 O(log N + M) 복잡도의 범위 검색 수행
- 모든 연산이 메모리에서 처리되어 디스크 I/O 없음

**Redis GeoHash 선택 이유**

| 비교 항목 | MySQL ST_DISTANCE | Redis GeoHash |
|-----------|-------------------|---------------|
| 저장소 | 디스크 기반 | 메모리 기반 |
| 거리 계산 | 매 요청마다 연산 | 사전 인덱싱된 해시값 비교 |
| 시간 복잡도 | O(N) 스캔 + 연산 | O(log N + M) |
| 캐시 효과 | Query Cache 의존 | 항상 메모리 히트 |
| 쓰기 부하 | 테이블 락 가능성 | 단일 키 연산 |

**적용 결과**
| 지표 | MySQL Spatial | Redis GeoHash |
|------|---------------|---------------|
| TPS | 37.16 | 431.46 |
| P95 응답시간 | 1.28s | 1.58s* |

*P95 증가는 테스트 부하량 차이 (100 VUs → 300 VUs)

---

## 3. 최종 성능 개선 결과

### 3.1 단계별 TPS 변화

| 단계 | 적용 기술 | TPS | 누적 개선율 |
|------|-----------|-----|-------------|
| 1단계 | Java Haversine (원본) | 3.83 | - |
| 2단계 | MySQL ST_DISTANCE_SPHERE + Spatial Index | 37.16 | 9.7x |
| 3단계 | Redis GeoHash (GEORADIUS) | 431.46 | **112.6x** |

### 3.2 핵심 지표 비교

| 지표 | 최초 | 최종 | 개선율 |
|------|------|------|--------|
| TPS | 3.83 | 431.46 | 112배 |
| 평균 응답시간 | 14.27s | 486ms | 29배 |
| 에러율 | 0.24% | 0% | 안정화 |
| 데이터 전송량 | 4.1GB | 509MB | 8배 감소 |

---

## 4. 현재 한계점 분석

### 4.1 서버 리소스 현황

| 항목 | 현재 값 | 정상 기준 | 상태 |
|------|---------|-----------|------|
| CPU Load Average | 7.79 | < 2.0 (2코어) | **과부하** |
| Memory | 1.1GB / 1.9GB | - | **부족** |
| Swap 사용량 | 1.2GB | 0 | **병목** |

### 4.2 병목 원인

**CPU 병목**
- Load Average 7.79는 2코어 서버에서 작업 대기열이 3.8배 초과됨을 의미
- 요청이 도착해도 처리할 CPU 여유가 없음

**메모리 병목**
- 물리 메모리 부족으로 1.2GB Swap 사용 중
- Swap은 디스크 기반으로 RAM 대비 1000배 느림
- 잦은 Page Fault로 응답 지연 발생

### 4.3 추가 소프트웨어 최적화가 어려운 이유

```
요청 처리 시간 분석:
├── Redis GEORADIUS: ~1ms (이미 최적)
├── JSON 직렬화: ~2ms (JVM 최적화 완료)
├── 네트워크 전송: ~10ms (물리적 한계)
└── CPU 대기 시간: ~400ms+ (병목 지점)

→ 코드에서 줄일 수 있는 시간: 거의 없음
→ CPU/메모리 부족이 근본 원인
```

---

## 5. 개선 방안

### 5.1 단기: 인스턴스 업그레이드

| 인스턴스 | 코어 | RAM | 예상 TPS | 월 비용 |
|----------|------|-----|----------|---------|
| t3.small (현재) | 2 | 2GB | 440 | ~$15 |
| t3.medium | 2 | 4GB | 600+ | ~$30 |
| t3.large | 2 | 8GB | 900+ | ~$60 |
| t3.xlarge | 4 | 16GB | 1,800+ | ~$120 |

**권장**: t3.large ($45 추가)로 Swap 제거 + TPS 2배 향상

### 5.2 중기: 아키텍처 분리

- Redis를 ElastiCache로 분리
- MySQL을 RDS로 분리
- 백엔드 서버는 애플리케이션 전용으로 운영

### 5.3 장기: 수평 확장

- Application Load Balancer 도입
- 백엔드 인스턴스 다중화 (Auto Scaling)
- 목표 TPS 3,000+ 달성 가능

---

## 6. 결론

### 달성 성과
- 소프트웨어 최적화로 **TPS 112배 향상** (3.83 → 431)
- P95 응답시간 **28초 → 1.58초**로 단축
- 에러율 0% 달성으로 서비스 안정성 확보

### 현재 상태
- Redis GeoHash 도입으로 소프트웨어 최적화 완료
- 현재 병목은 하드웨어 리소스 (CPU/메모리)
- 추가 성능 향상을 위해 인프라 투자 필요

### 제안
> **월 $45 추가 투자 (t3.small → t3.large)로 TPS 2배 향상 및 서버 안정성 확보 가능**
